Система управления зоопарком

Данный проект представляет собой программный комплекс на языке Java 
для автоматизации учета животных, сотрудников и вольеров в зоопарке. 
Система спроектирована с использованием принципов объектно-ориентированного
программирования SOLID.

Основные компоненты
Управление сущностями: Реализован учет различных видов животных 
(Lion, Snake, Parrot, Pike) и типов сотрудников (Feeder, Cleaner, Veterinarian).

Инфраструктура: Класс Enclosure обеспечивает контроль вместимости и уровня чистоты.

Отчетность: Класс ReportGenerator формирует аналитические данные 
на основе интерфейсов-провайдеров данных.

Программа реализована в соответствии с разработанной диаграммой классов.

Проект разработан с учетом пяти принципов объектно-ориентированного проектирования SOLID:
![Диаграмма классов.png](%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2.png)
1. Single Responsibility Principle (Принцип единственной ответственности)
   Каждый класс выполняет строго определенную задачу:
- Zoo - агрегирует списки и управляет составом зоопарка.
- Enclosure - отвечает исключительно за содержание животных и гигиену пространства.
- ReportGenerator - вынесен в отдельный модуль для формирования вывода, 
чтобы не смешивать бизнес-логику с формированием отчетов.

2. Open/Closed Principle (Принцип открытости/закрытости)

Система открыта для расширения, но закрыта для модификации:
Для добавления нового вида животного достаточно создать новый подкласс наследник
от Animal. При этом не требуется вносить изменения в существующие классы Zoo 
или ReportGenerator.
Поведение животных (голос, метод питания) переопределяется в подклассах.

3. Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

Все подклассы животных и сотрудников могут использоваться вместо своих 
базовых типов без нарушения логики программы: Метод feedAllAnimals в классе Zoo 
работает с абстракцией Animal, принимая любой объект (Lion, Snake и т.д.) корректно.

Сотрудники корректно замещают абстрактный класс Employee.

4. Interface Segregation Principle (Принцип разделения интерфейса)

Вместо одного универсального интерфейса созданы узкоспециализированные:
Healable — для ветеринаров.
Cleanable — для уборщиков.
Feedable — для кормильцев. 

Это избавляет классы от необходимости реализовывать методы, которые они не используют. 

Для отчетности также разделены провайдеры данных: ZooInfoProvider, 
AnimalInfoProvider и EnclosureInfoProvider.

5. Dependency Inversion Principle (Принцип инверсии зависимостей)

Классы верхних уровней не зависят от классов нижних уровней. 
Оба зависят от абстракций:
ReportGenerator не требует объект Zoo напрямую, 
а работает через интерфейсы ZooInfoProvider или AnimalInfoProvider. 
Это позволяет подставлять любую систему, реализующую данный интерфейс, 
упрощая тестирование и масштабирование.


Проблемы при масштабировании проекта:
1. Отсутствие обработки ошибок - методы удаления и добавления объектов возвращают 
void и сообщение об ошибке, но никак ее не обрабатывают. Это может привести к накоплению
скрытых ошибок.
2. Метод eating() имеет схожую структуру, если его унифицировать, будет проще создавать
новые классы животных.

Аргументы, почему введенные абстракции улучшили качество дизайна:
1. Класс ReportGenerator теперь ничего не знает о внутреннем устройстве Zoo. 
Он лишь «просит» данные через интерфейс. Это позволяет менять логику хранения 
животных в классе Zoo, не затрагивая код отчетов.
2. Благодаря тому, что все животные наследуются от Animal, метод 
moscowZoo.addAnimal(Animal animal) может принимать любой объект — существующий 
или созданный в будущем. Программа работает с абстрактным «животным», 
что делает её универсальной.
3. Вместо общего интерфейса IZoo, он разделен его на AnimalInfoProvider, 
EmployeeInfoProvider, EnclosureInfoProvider. Это гарантирует, что модуль отчетов 
по животным не получит доступ к методам управления сотрудниками,
которые ему не нужны. Это повышает безопасность и читаемость кода.